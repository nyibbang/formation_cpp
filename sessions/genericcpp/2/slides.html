<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Formation programmation multithread en C++</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../themes/ingima2.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../../contrib/deck.js/themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="../../../contrib/deck.js/core/print.css">

  <!-- prism.js -->
  <link rel="stylesheet" href="../../themes/prism.css">

  <!-- Required Modernizr file -->
  <script src="../../../contrib/deck.js/modernizr.custom.js"></script>
</head>
<body class="language-cpp">

  <div class="home">

    <article class="deck-container">

  <!--
  #########################################################################################################
  # Content
  #########################################################################################################
  -->

<section class="slide title">
  <h1>Programmation<br>multithread en C++</h1>
</section>

<section class="slide">
  <h2>Introduction</h2>
  <h3>Objectifs</h3>
  <ul>
    <li><strong>Reprendre les concepts de base de la programmation multithread</strong>;</li>
    <li><strong>Découvrir les outils de la STL pour le multithread en C++ (11)</strong>.</li>
  </ul>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li><h4>Théorie et raisonnement</h4></li>
    <li><h4>Outils du langage et de la STL</h4></li>
    <li><h4>TP application</h4></li>
    <li><h4>Réflexion</h4></li>
    <li><h4>Conclusion</h4></li>
    <li><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li>
      <h4>Théorie et raisonnement</h4>
      <ol>
        <li>Définitions;</li>
        <li class="faded">Mauvaises raisons d'en faire;</li>
        <li class="faded">Bonnes raisons d'en faire.</li>
      </ol>
    </li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Concurrence</h3>
  <ul>
    <li>Plusieurs codes peuvent être découpés;</li>
    <li>Les morceaux découpés peuvent être executés <strong>tour à tour pas forcément en bloc</strong> (interleaving).</li>
    <li>A B &rArr; A1 B1 B2 A2 B3 A3 A4;</li>
    <li>Exemple : du code multithreadé sur une machine monoc&oelog;ur.</li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Parallélisme</h3>
  <p>Plusieurs codes sont executés <strong>en même temps</strong>.</p>
  <p><q>Concurrency is not parallelism.</q> Rob Pike (<a href="https://vimeo.com/49718712">https://vimeo.com/49718712</a>)</p>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Thread</h3>
  <ul>
    <li>Fil d'exécution;</li>
    <li>Partage la mémoire avec les autres threads d'un même processus;</li>
    <li>Possède sa propre pile d'exécution.</li>
  </ul>
  <p>Différences par rapport à un fork ?</p>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Thread-safety</h3>
  <p><strong>Attention</strong>, terme ambigu.</p>
  <ul>
    <li>S'applique à un du code par rapport à un autre (ou lui même);</li>
    <li>Vérifiée quand les 2 codes peuvent être appelés simultanément sans data race;</li>
    <li>Appliquée à une classe
      <ul>
        <li>Méthodes de la classe peuvent être appelées <strong>simultanément sur même objet</strong>;</li>
        <li>Attention aux <strong>combinaison de méthodes</strong> (notamment ctor et dtor) !</li>
      </ul>
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Réentrance</h3>
  <ul>
    <li>Réentrance &ne; Thread safety;</li>
    <li>Code qui peut être réexécuté en même temps qu'il l'est déjá;
      <ul>
        <li>Soit par lui même (par récursivité);</li>
        <li>Soit par un autre thread (pas forcément les mêmes paramètres, notamment <em>this</em>).</li>
      </ul>
    </li>
    <li>Exclure du code par un mutex
      <ul>
        <li><strong>Empêche</strong> la réentrance (sauf si mutex recursif);</li>
        <li><strong>Permet en général</strong> la thread safety.</li>
      </ul>
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3><em>Data race</em> ou <em>race condition</em></h3>
  <ul>
    <li>Lorsque la bonne exécution d'un code dépend du séquencement des threads;</li>
    <li>Modification / lecture de donnée par plusieurs opérations concurrentes sans synchronisation;</li>
    <li><strong>Undefined behavior</strong> ! Résultat indéterministe.</li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Définitions</h2>
  <h3>Primitives de synchronisation</h3>
  <p>Entre autres :</p>
  <ul>
    <li>Mutexes;</li>
    <li>Atomics;</li>
    <li>Sémaphores;</li>
    <li>Memory barriers/fences;</li>
    <li>Condition variables.</li>
  </ul>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li>
      <h4>Théorie et raisonnement</h4>
      <ol>
        <li class="faded">Définitions;</li>
        <li>Mauvaises raisons d'en faire;</li>
        <li class="faded">Bonnes raisons d'en faire.</li>
      </ol>
    </li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Mauvaises raisons d'en faire</h2>
  <h3>Risques (1/2)</h3>
  <ul>
    <li>Data races
      <ul>
        <li>Partage de données;</li>
        <li>Partage de ressources.</li>
      </ul>
    </li>
    <li>Complexification du code
      <ul>
        <li>Utilisation de <strong>primitives de synchronisation</strong>;</li>
        <li>Besoin de porter une plus grande <strong>attention aux détails</strong>.</li>
      </ul>
    </li>
    <li>Gain de performances ?
      <ul>
        <li>Le code ne <strong><em>scale</em> pas</strong> nécessairement;</li>
        <li>Il existe souvent des <strong>goulots d'étranglement</strong>;</li>
        <li>Il y a répétition de <strong>changements de contextes</strong>;</li>
        <li><strong>Loi d'Amdahl</strong> : l'accélération théorique est limitée par la partie séquentielle du code.<br/><a
            href="https://fr.wikipedia.org/wiki/Loi_d%27Amdahl">https://fr.wikipedia.org/wiki/Loi_d%27Amdahl</a></li>
      </ul>
    </li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Mauvaises raisons d'en faire</h2>
  <h3>Risques (2/2)</h3>
  <img src="../../media/concurrency_perf.png"/>
  <p>Tiré de <em>Better Code: Concurrency</em>, Sean Parent</p>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Mauvaises raisons d'en faire</h2>
  <h3>Alternatives au multithread (1/2)</h3>
  <h4>Event loop</h4>
  <ul>
    <li>Voir par exemple l'implémentation de Qt (QEventLoop);</li>
    <li>Une boucle infinie de dispatch d'évènements;</li>
    <li>Les évènements sont traités par des <strong>handlers</strong>;</li>
    <li>Les handlers <strong>rendent la main à l'EventLoop</strong> après traitement;</li>
    <li>Les handlers <strong>injectent de nouveaux évènements</strong> lors du traitement.</li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Mauvaises raisons d'en faire</h2>
  <h3>Alternatives au multithread (2/2)</h3>
  <h4>Coroutines</h4>
  <ul>
    <li>Voir boost.Coroutines ou boost.Coroutines2;</li>
    <li>Potentiellement implémentées en C++20;<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4723.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4723.pdf</a></li>
    <li>Contrôle du changement de contexte intégré au langage;</li>
    <li>Similaire aux générateurs en python.</li>
  </ul>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li>
      <h4>Théorie et raisonnement</h4>
      <ol>
        <li class="faded">Définitions;</li>
        <li class="faded">Mauvaises raisons d'en faire;</li>
        <li>Bonnes raisons d'en faire.</li>
      </ol>
    </li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Bonnes raisons d'en faire</h2>
  <h3>Asynchronisme et <em>responsiveness</em></h3>
  <ul>
    <li>Certains routines ne doivent <strong>pas être bloquées</strong> (ex: GUI);</li>
    <li>Malgré l'appel à des <strong>opérations lentes ou coûteuses</strong>, exemple :
      <ul>
        <li>Input/Ouput (GUI events, système de fichiers, réseau, BDD, ...);</li>
        <li>Calcul lourd (image processing, simulation, ...);</li>
      </ul>
    </li>
    <li>Il est alors nécessaire de les lancer de façon <strong>asynchrone</strong>;</li>
    <li>Par exemple en les exécutant dans <strong>un autre thread</strong>.</li>
  </ul>
</section>

<section class="slide">
  <h2>Théorie et raisonnement &rarr; Bonnes raisons d'en faire</h2>
  <h3>Parallélisme</h3>
  <ul>
    <li>Certains algorithmes sont connus pour être <strong>parallélisables</strong>;</li>
    <li>Il est utile de les <strong>découper sur plusieurs threads</strong>;</li>
    <li>Pour ainsi <strong>gagner en performances</strong> sur des machines multic&oelig;urs;</li>
    <li>Néanmoins dans ce genre de cas, se tourner vers des solutions comme <strong>OpenCL ou CUDA</strong>;</li>
  </ul>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li>
      <h4>Outils du langage et de la STL</h4>
      <ol>
        <li>Langage
          <ul>
            <li>Variables volatile;</li>
            <li>Variables thread_local;</li>
            <li>Magic static.</li>
          </ul>
        </li>
        <li class="faded">Bibliothèque
          <ul>
            <li>Threads;</li>
            <li>Mutexes;</li>
            <li>Condition variables;</li>
            <li>Atomics;</li>
            <li>Promise/future;</li>
            <li>Utilitaires.</li>
          </ul>
        </li>
      </ol>
    </li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Langage</h2>
  <h3>Variables volatile</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Langage</h2>
  <h3>Variables thread_local</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Langage</h2>
  <h3>Magic static</h3>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li>
      <h4>Outils du langage et de la STL</h4>
      <ol>
        <li class="faded">Langage
          <ul>
            <li>Variables volatile;</li>
            <li>Variables thread_local;</li>
            <li>Magic static.</li>
          </ul>
        </li>
        <li>Bibliothèque
          <ul>
            <li>Threads;</li>
            <li>Mutexes;</li>
            <li>Condition variables;</li>
            <li>Atomics;</li>
            <li>Promise/future;</li>
            <li>Utilitaires.</li>
          </ul>
        </li>
      </ol>
    </li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Avant-propos</h3>
Qu'est ce qui est thread-safe dans la STL ?
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Threads</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Mutexes</h3>
      - std::mutex
      - std::recursive_mutex
      - std::unique_lock, std::lock_guard
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Condition variables</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Atomics</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Promise/future</h3>
</section>

<section class="slide">
  <h2>Outils du langage et de la STL &rarr; Bibliothèque</h2>
  <h3>Utilitaires</h3>
      - std::async
      - std::packaged_task
      - std::lock
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>TP application</h2>
  <h3>Producer/consumer</h3>
  <p>Disponible dans <strong>sessions/genericcpp/2/practical</strong></p>
  <ul>
    <li>Ouvrir le <em>CMakeLists.txt</em> à la racine du dépôt avec votre IDE favori.</li>
    <li>Ouvrir le fichier <strong>practical.cpp</strong> dans le projet <strong>genericcpp_sess2</strong>.</li>
    <li>Coder la fonction <code>consumer_multithread</code>.</li>
  </ul>
</section>

<section class="slide">
  <h2>TP application</h2>
  <h3>Conclusion</h3>
  <p>Qu'en pensez-vous ?</p>
  <ul>
    <li>Gain de performances ?</li>
    <li>Bonne utilisation de la concurrence ?</li>
    <li>Facile à lire / à écrire ?</li>
    <li>Est-on sûrs de n'avoir fait aucune erreur / data-race ?</li>
    <li>Facile à tester ?</li>
  </ul>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li>
      <h4>Réflexion</h4>
      <ol>
        <li>Conseils et bonnes pratiques;</li>
        <li class="faded">Concepts haut niveau.</li>
      </ol>
    </li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Réflexion</h2>
  <h3>Conseils et bonnes pratiques</h3>
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li>
      <h4>Réflexion</h4>
      <ol>
        <li class="faded">Conseils et bonnes pratiques;</li>
        <li>Concepts haut niveau.</li>
      </ol>
    </li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Réflexion</h2>
  <h3>Concepts haut niveau</h3>
    - Concurrent queue
    - Executors
    - Strand
    - Worker
    - Threadpool
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li><h4>Conclusion</h4></li>
    <li class="faded"><h4>Quizz</h4></li>
  </ol>
</section>

<section class="slide">
  <h2>Conclusion</h2>
  <h3>Résumé</h3>
  <ul>
    <li>;</li>
    <li>;</li>
    <li>.</li>
  </ul>
</section>

<section class="slide">
  <h2>Conclusion</h2>
  <h3>Recommandations</h3>
http://sean-parent.stlab.cc/papers-and-presentations#better-code-concurrency
</section>

<section class="slide">
  <h2>Programmation multithread en C++</h2>
  <h3>Plan</h3>
  <ol>
    <li class="faded"><h4>Théorie et raisonnement</h4></li>
    <li class="faded"><h4>Outils du langage et de la STL</h4></li>
    <li class="faded"><h4>TP application</h4></li>
    <li class="faded"><h4>Réflexion</h4></li>
    <li class="faded"><h4>Conclusion</h4></li>
    <li><h4>Quizz</h4></li>
  </ol>
</section>

  <!--
  #########################################################################################################
  # End of content
  #########################################################################################################
  -->

      <!-- Begin extension snippets. Add or remove as needed. -->

      <!-- deck.navigation snippet -->
      <div aria-role="navigation">
        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>
      </div>

      <!-- deck.status snippet -->
      <p class="deck-status" aria-role="status">
        <span class="deck-status-current"></span>
        /
        <span class="deck-status-total"></span>
      </p>

      <!-- deck.goto snippet -->
      <form action="." method="get" class="goto-form">
        <label for="goto-slide">Go to slide:</label>
        <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
        <datalist id="goto-datalist"></datalist>
        <input type="submit" value="Go">
      </form>

      <!-- End extension snippets. -->

    </article>

  </div>

  <!-- Required JS files. -->
  <script src="../../../contrib/deck.js/jquery.min.js"></script>
  <script src="../../../contrib/deck.js/core/deck.core.js"></script>

  <!-- Extension JS files. Add or remove as needed. -->
  <script src="../../../contrib/deck.js/extensions/menu/deck.menu.js"></script>
  <script src="../../../contrib/deck.js/extensions/goto/deck.goto.js"></script>
  <script src="../../../contrib/deck.js/extensions/status/deck.status.js"></script>
  <script src="../../../contrib/deck.js/extensions/navigation/deck.navigation.js"></script>
  <script src="../../../contrib/deck.js/extensions/scale/deck.scale.js"></script>

  <!-- Initialize the deck. You can put this in an external file if desired. -->
  <script>
    $(function() {
      $.deck('.slide');
    });
  </script>

  <!-- prism.js -->
  <script src="../../themes/prism.js"></script>

</body>
</html>
