<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>C++ moderne : perfectionnement</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../themes/ingima.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/themes/transition/fade.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="../../contrib/deck.js/core/print.css">

  <!-- prism.js -->
  <link rel="stylesheet" href="../themes/prism.css">

  <!-- Required Modernizr file -->
  <script src="../../contrib/deck.js/modernizr.custom.js"></script>
</head>
<body class="language-cpp">

  <header>
    <img src="../media/ingima-logo.png" class="logo">
  </header>

  <div class="home">

    <article class="deck-container">

  <!--
  #########################################################################################################
  # Content
  #
  # Title slide:
  #
  # <section class="slide title">
  #   <h1>Section</h1>
  # </section>
  #
  # Slide
  #
  # <section class="slide">
  #   <h2>Section &rarr; Subsection</h2>
  #   <h3>Subsubsection</h3>
  #   <ul>
  #     <li><strong>Bla;</li>
  #   </ul>
  #   <p>
  #     Bla
  #   </p>
  # </section>
  #
  # Code slide
  #
  # <section class="slide">
  #   <h2>Section &rarr; Subsection</h2>
  #   <h3>Subsubsection</h3>
  #   <pre><code>
  #   a = 42;
  # </code></pre>
  # </section>
  #
  # Plan
  #
  # <section class="slide">
  #   <h2>Section</h2>
  #   <h3>Plan</h3>
  #   <ol>
  #     <li class="faded"><h4>Passed subsection</h4></li>
  #     <li>
  #       <h4>Subsection</h4>
  #       <ol>
  #         <li>subsubsection</li>
  #       </ol>
  #     </li>
  #     <li class="faded"><h4>Incoming subsection</h4></li>
  #   </ol>
  # </section>
  #
  #########################################################################################################
  -->

<section class="slide title">
  <h1>Maîtrise et perfectionnement<br/>en C++ moderne<br/>
    <small>Première partie<br/>23 octobre 2018</small>
  </h1>
</section>

<section class="slide">
  <h2>Introduction</h2>
  <h3>Vincent Palancher, développeur C++</h3>
  <ul>
  <li class="slide">Formation d'ingénieur à l'Université de Technologie de Compiègne (UTC) en 2012.</li>
  <li class="slide">6 ans d'expérience.<ul>
      <li class="slide">6 mois chez <strong>General Electrics</strong>.
        <ul><li>Logiciel de traitement d'images médicales (C++).</li></ul>
      </li>
      <li class="slide">3 ans chez <strong>CS</strong>.
        <ul><li>Logiciel de contrôle aérien (C++11/Qt).</li></ul>
      </li>
      <li class="slide">1 an chez <strong>Ineo Défense</strong>.
        <ul><li>Logiciel de contrôle d'équipement radio (C++11/Qt5).</li></ul>
      </li>
      <li class="slide">1 an et demi chez <strong>SoftBank Robotics Europe</strong>.
        <ul><li>Bibliothèque embarquée de communication pour robot (C++11 et +).</li></ul>
      </li>
    </ul>
  </li>
  </ul>
  <h3 class="slide">A vous !</h3>
</section>

<section class="slide">
  <h2>Introduction (2)</h2>
  <h3>Objectifs</h3>
  <ul>
    <li class="slide">Arrêter le C++98/03 !</li>
    <li class="slide">Mieux comprendre le C++11.
      <ul><li>On rentrera plus en détail que la dernière formation.</li></ul>
    </li>
    <li class="slide">Se préparer aux prochaines normes.</li>
  </ul>
</section>

<section class="slide">
  <h2>Introduction (3)</h2>
  <h3>Première partie</h3>
  <ul>
    <li class="slide"><em>nullptr</em></li>
    <li class="slide"><em>for-range loop</em></li>
    <li class="slide"><em>auto</em></li>
    <li class="slide"><em>override</em>, <em>final</em></li>
    <li class="slide"><em>lambdas</em></li>
    <li class="slide"><em>smart pointers</em></li>
    <li class="slide"><em>constexpr</em></li>
    <li class="slide"><em>initializer_list</em></li>
    <li class="slide">Et plus encore.</li>
  </ul>
</section>

<section class="slide">
  <h2>Préambule</h2>
  <h3>Comment s'améliorer en C++ ?</h3>
  <p class="slide">Il suffit de lire la documentation !</p>
  <section class="slide">
    <h4>Où la trouver ?</h4>
    <ul>
      <li><a href="https://en.cppreference.com">https://en.cppreference.com</a></li>
      <li><a href="https://fr.cppreference.com">https://fr.cppreference.com</a> (pas à jour)</li>
    </ul>
  </section>
  <section class="slide">
    <h4>Outils utiles</h4>
    <ul>
      <li><a href="https://godbolt.org">https://godbolt.org</a>, pour compiler, inspecter l'asm avec différents compilateurs.</li>
      <li><a href="http://quick-bench.com">http://quick-bench.com</a>, pour benchmarker.</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Documentation</h2>
  <ul>
    <li class="slide">Compiler support.</li>
    <li class="slide">Langage.</li>
    <li class="slide">Bibliothèque standard.</li>
  </ul>
</section>

<!-- nullptr -->
<section class="slide">
  <h2><em>nullptr</em></h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Constante de type <code>std::nullptr_t</code> implicitement convertible en pointeur.</p>
    <p class="slide">Equivalent à la macro <code>NULL</code>.</p>
  </section>

  <section class="slide">
    <h3>Quel est le problème ?</h3>
    <p class="slide"><code>#define NULL 0</code> &rarr; type ambigu</p>
    <pre class="slide"><code>void foo(int);
void foo(void*);
foo(NULL); // Quelle overload est appelée ?</code></pre>
  </section>

  <section class="slide">
    <h3>Comment l'utiliser ?</h3>
    <p class="slide">Remplacer tous les <code>NULL</code> par <code>nullptr</code>. Simple.</p>
    <p class="slide">A partir de C++11, <code>#define NULL nullptr</code>.</p>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo1</em></h3>
    <p>Possibilité de surcharger ses fonctions pour <code>nullptr</code>.</p>
    <p>Est-ce suffisant pour ne pas vérifier les pointeurs nuls dans les autres surcharges ?</p>
  </section>
</section>

<!-- for-range for -->
<section class="slide">
  <h2><em>range for loop</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Un moyen d'itérer simplement sur les <em>ranges</em> (comme les conteneurs).</p>
  </section>

  <section class="slide">
    <h3>Equivalence (simplifiée)</h3>
    <pre class="slide"><code>for (auto&amp;&amp; elem : range) {
  code
}</code></pre>
    <pre class="slide"><code>for (auto begin = range.begin(), end = range.end(); begin != end; ++begin) {
  auto&amp;&amp; elem = *begin;
  code
}</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi l'utiliser ?</h3>
    <p class="slide">Plus concis, plus clair, évite les problèmes de <em>bound checking</em>.</p>
    <pre class="slide"><code>for (int i = 0; i &lt; range.size(); ++i) {
  if (range[i] == range[i + 1]) // woops, erreur simple à éviter mais obscure
    doublon();
}</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo2</em></h3>
    <p>Implémenter un range simple sur lequel itérer dans une boucle.</p>
  </section>
</section>

<!-- auto -->
<section class="slide">
  <h2>Type inference: <em>auto</em></h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Un mot clé pour forcer le compilateur à déduire le type d'une variable.</p>
    <pre class="slide"><code>auto i = 42; // i est un 'int'
auto s = "abc"; // s est un 'const char*'</code></pre>
    <section class="slide">
      <p>Permet de créer des variables dont le type n'est pas expressible.</p>
      <pre><code>??? myfunc = []{ return 42; } // Woops</code></pre>
    </section>
  </section>

  <section class="slide">
    <h3>Qu'est-ce que ça n'est pas ?</h3>
    <p class="slide">Un type magique qui peut contenir n'importe quoi !</p>
    <p class="slide">Le type est <strong>déduit à la compilation</strong> et <strong>ne peut pas changer</strong>.</p>
  </section>
</section>

<section class="slide">
  <h2>Type inference: <em>auto</em> (2)</h2>
  <h3>Polémique</h3>

  <section class="slide">
    <h4>Reproches</h4>
    <ul>
      <li class="slide">On ne sait plus quel type on manipule, obfuscation du code (clarté).</li>
      <li class="slide">Pour certains développeurs, c'est un manque de rigueur (paresse).</li>
      <li class="slide">Plutôt que spécifier le type de notre variable, on
        dépend de ce que la fonction retourne (engagement).</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Type inference: <em>auto</em> (3)</h2>
  <h3>Polémique (2)</h3>
  <section class="slide">
    <h4>AAA Style (almost always auto)</h4>
    <p class="slide">Herb Sutter, membre du comité C++,
      <a href=https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/>
        lien</a>.
    </p>
    <ul>
      <li class="slide">Consistence, performance: Le compilateur ne se trompe jamais sur le
        type qu'il déduit. Il évite aussi les conversions implicites.</li>
      <li class="slide">Clarté:<br/><em>auto</em> ne cache pas nécessairement le type. Certains développeurs conseillent la syntaxe suivante.
        <pre><code>auto s = string{"abc"}; // la conversion est plus claire que 'string s{"abc"}'
                        // la syntaxe est plus homogène avec le reste du code</code></pre>
        Les IDE amortissent l'impact d'<em>auto</em> sur la lisibilité, et certains types au nom très long nuisent à
        la lecture.
        <pre><code>std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt; mymap;
std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;::iterator it = mymap.begin(); // on se répète non ?
auto it = mymap.begin(); // ça semble évident.</code></pre>
      </li>
      <li class="slide">Engagement: Il ne faut pas se rendre dépendant des implémentations mais des interfaces.<br/>
        <em>auto</em> est le <strong>concept</strong> le moins contraignant et donc le plus faible.
        <pre><code>Iterator it = myvector.begin();
// Ici Iterator ne serait pas un type mais un concept. L'interface est claire,
// l'implémentation (le véritable type) est cachée.  Le code est plus clair et documenté que
// auto it = myvector.begin();</code></pre>
      </li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Type inference: <em>auto</em> (4)</h2>
  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo3</em></h3>
    <p>Transformer les types de variables en <em>auto</em>.</p>
  </section>
</section>

<!-- override, final -->
<section class="slide">
  <h2><em>override</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Déclare que la méthode virtuelle est une réimplémentation de la méthode de la classe parente.</p>
    <pre class="slide"><code>class Mother {
  virtual void do_stuff();
};
class Daughter : public Mother {
  void do_stuff() override;
};</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi c'est utile ?</h3>
    <p class="slide">Cela évite les erreurs de signatures.</p>
    <pre class="slide"><code>class Mother {
  virtual void do_stuff(int a); // Quelqu'un a ajouté un paramètre !
};
class Daughter : public Mother {
  void do_stuff(); // Avant: pas d'erreur, le code compile mais la méthode n'est plus surchargée.
  void do_stuff() override; // Après: erreur de compilation
};</code></pre>
  </section>

  <section class="slide">
    <h3>Quand l'utiliser ?</h3>
    <p>Partout où c'est possible !</p>
  </section>
</section>

<section class="slide">
  <h2><em>final</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Déclare qu'une méthode ou un classe ne peut pas être réimplémentée.</p>
    <pre class="slide"><code>class Mother final {
};
class Daughter : public Mother { // erreur
};</code></pre>
    <pre class="slide"><code>class Mother {
  virtual void do_stuff() final;
};
class Daughter : public Mother {
  void do_stuff() override; // erreur
};</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi c'est utile ?</h3>
    <p>Empêche la surcharge et permet de mieux contrôler l'implémentation.</p>
  </section>
</section>

<section class="slide">
  <h2><em>final</em> (2)</h2>

  <section class="slide">
    <h3>Quand l'utiliser ?</h3>
    <p class="slide">Avec parcimonie.<br/>Un exemple :</p>
    <pre class="slide"><code>class Base {
  virtual void do_stuff() = 0;
};
class Do_stuff_then_a_then_b_then_c : public Base {
  void do_stuff() final override { // On ne veut pas que les filles touchent à cette implem,
                                   // mais plutôt aux autres méthodes, car cela fait partie
                                   // de l'invariant de cette classe.
    do_a();
    do_b();
    do_c();
  }
  virtual void do_a() = 0;
  virtual void do_b() = 0;
  virtual void do_c() = 0;
};</code></pre>
  </section>
</section>

<section class="slide">
  <h2>Lambdas</h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Une fonction anonyme. Elle peut accéder aux variables de son scope.</p>
    <pre class="slide"><code>void foo() {
  int a = 42;
  auto fun = [&amp;]{
    return a + 2;
  };
  int b = fun() + 10;
  assert(b == 54);
}</code></pre>
  </section>

  <section class="slide">
    <h3>Syntaxe</h3>
    <pre class="slide"><code>[captures](arguments) mutable? { code }</code></pre>
    <ul>
      <li class="slide">Captures:
        <ul>
          <li class="slide">Capture par copie : <code>variable</code></li>
          <li class="slide">Capture par référence : <code>&amp;variable</code></li>
          <li class="slide">Capture tout par copie : <code>=</code></li>
          <li class="slide">Capture tout par référence : <code>&amp;</code></li>
        </ul>
      </li>
      <li class="slide"><code>mutable</code> : la lambda peut modifier ses captures.</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Lambdas (2)</h2>
  <section class="slide">
    <h3>Equivalence</h3>
    <pre><code>struct Lambda {
  captures;
  auto operator()(arguments) const? {
    code
  }
};</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo4</em></h3>
    <p>Chercher un élément dans un vecteur.</p>
  </section>
</section>

<section class="slide">
  <h2>RAII</h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide"><strong><em>Resource Acquisition is Initialization</em></strong>.</p>
    <p class="slide">Encapsulation d'une ressource dans un objet alloué sur la pile.</p>
    <p class="slide">Exemples de ressources :</p>
    <ul>
      <li class="slide">Allocation mémoire.</li>
      <li class="slide">Ouverture d'un fichier.</li>
      <li class="slide">Acquisition d'un mutex.</li>
    </ul>
    <p class="slide">En général, tout ce qui a une étape d'initialisation et une étape de nettoyage.</p>
  </section>
</section>

<section class="slide">
  <h2>RAII (2)</h2>

  <section class="slide">
    <h3>Quel intérêt ?</h3>
    <p class="slide">Protéger les ressources des multiples points de sortie d'une fonction.</p>
    <p class="slide">Une fonction peut se terminer à cause de :</p>
    <ul>
      <li class="slide">Une instruction <code>return</code>.</li>
      <li class="slide">Une exception.</li>
    </ul>
    <p class="slide">Toujours s'assurer de l'état de l'objet ou de la fonction si une exception est levée !</p>
  </section>

  <pre class="slide"><code>struct Object {
  enum State { Working, Waiting };
  State _state;

  void foo() {
    int* p = new int{42};
    _state = Working;
    bar(); // Si bar lève une exception:
           //   - fuite mémoire car le pointeur n'est pas libéré.
           //   - l'objet reste en état 'Working' alors que la fonction est terminée.
    _state = Waiting;
    delete p;
  }
};</code></pre>
</section>

<section class="slide">
  <h2>RAII (3)</h2>

  <section class="slide">
    <h3>Comment fait-on ?</h3>
    <p class="slide">
      Si possible utiliser des types existants: <code>std::unique_ptr</code>,
      <code>std::lock_guard</code>, <code>std::unique_lock</code>, etc.
    </p>
    <pre class="slide"><code>struct Raii_object {
  Resource_handle _handle;

  Raii_object()
    : _handle(alloc_resource) {
  }
  ~Raii_object() {
    release_resource(_handle);
  }
};</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice forma3_sess1_exo5</h3>
    <p>Rendre une fonction <em>exception-safe</em>.</p>
  </section>
</section>

<section class="slide">
  <h2>Smart pointers</h2>
  <h3><em>unique_ptr</em></h3>

  <section class="slide">
    <h4>Qu'est-ce que c'est ?</h4>
    <p class="slide">Wrapper <strong>RAII</strong> d'un pointeur. Il représente la propriété
      (<em>ownership</em>) d'un pointeur qui est <strong>unique</strong>.</p>
    <p class="slide"><code>std::unique_ptr&lt;int&gt;</code></p>
    <p class="slide">Peut se baser sur un <strong><em>Deleter</em></strong> personnalisé.</p>
    <p class="slide"><code>std::unique_ptr&lt;int, Deleter&gt;</code></p>
    <p class="slide">N'est <strong>pas copiable</strong> (il doit rester unique) mais <strong>déplaçable</strong>.</p>
  </section>

  <section class="slide">
    <h4>Quand l'utiliser ?</h4>
    <p class="slide">C'est le choix par défaut.</p>
    <p class="slide">A chaque allocation dynamique (<em>new</em>), utiliser un <em>unique_ptr</em>.</p>
    <pre class="slide"><code>struct Factory {
  std::unique_ptr&lt;Object&gt; create_object() {
    std::unique_ptr&lt;Object&gt; new_object(new Object);
    new_object-&gt;prepare();
    return new_object;
  }
};</code></pre>
  </section>
</section>

<section class="slide">
  <h2>Smart pointers (2)</h2>
  <h3><em>shared_ptr</em></h3>

  <section class="slide">
    <h4>Qu'est-ce que c'est ?</h4>
    <p class="slide">Wrapper <strong>RAII</strong> d'un pointeur. Il représente la propriété
    (<em>ownership</em>) d'un pointeur qui est <strong>partagée</strong>.</p>
    <p class="slide"><code>std::shared_ptr&lt;int&gt;</code></p>
    <p class="slide">Peut se baser sur un <strong><em>Deleter</em></strong> personnalisé.</p>
    <p class="slide">Est <strong>copiable</strong> et <strong>déplaçable</strong>.</p>
  </section>

  <section class="slide">
    <h4>Comment ça marche ?</h4>
    <p class="slide">Allocation d'un <em>shared state</em> qui possède un <strong>compteur de référence</strong>.</p>
    <p class="slide">Chaque copie incrémente le compteur, et le décrémente lorsqu'elle est détruite.</p>
    <p class="slide">La <strong>dernière copie</strong> (le compteur atteint 0) libère l'objet alloué.</p>
  </section>

  <section class="slide">
    <h4>Quand l'utiliser ?</h4>
    <p>Avec <strong>parcimonie</strong>.</p>
    <ul>
      <li class="slide">Ils sont moins contraignants à utiliser que les <em>unique_ptr</em>, mais les contraintes libèrent !</li>
      <li class="slide">La copie est coûteuse à cause du <em>shared_state</em>.</li>
      <li class="slide">Attention aux cycles (difficiles à debugger) !</li>
      <li class="slide">Attention au partage en plusieurs threads !</li>
    </ul>
    <p class="slide">Ils sont en général surutilisés car très simple à mettre en place.</p>
  </section>
</section>

<section class="slide">
  <h2>Smart pointers (3)</h2>
  <h3><em>weak_ptr</em></h3>

  <section class="slide">
    <h4>Qu'est-ce que c'est ?</h4>
    <p class="slide">Une référence <strong>non propriétaire</strong> d'un pointeur partagé.</p>
    <p class="slide"><code>std::weak_ptr&lt;int&gt;</code></p>
  </section>

  <section class="slide">
    <h4>A quoi ça sert ?</h4>
    <p>Principalement à <strong>éviter les cycles</strong> entre <em>shared_ptr</em>.</p>
  </section>
</section>

<section class="slide">
  <h2>Smart pointers (4)</h2>
  <h3>Exercice forma3_sess1_exo6</h3>
  <p>Mettre en place des <em>smart pointers</em>.</p>
  <p>Penser à retoucher les tests aussi.</p>
</section>

<section class="slide">
  <h2><em>initializer_list</em></h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Un type qui représente une liste d'éléments <code>{ elem1, elem2, ... }</code>.</p>
    <p class="slide"><strong>N'alloue pas</strong> de mémoire dynamiquement.</p>
    <p class="slide">Equivalent à passer une pair de pointeurs désigniant le début et la fin d'un tableau statique.</p>
    <p class="slide">La copie <strong>ne copie pas</strong> les éléments.</p>
  </section>

  <section class="slide">
    <h3>A quoi ça sert ?</h3>
    <p class="slide">Permet d'initialiser ses types plus simplement.</p>
    <pre class="slide"><code>struct MyVector {
  std::string concatenated_values;

  void operator=(std::initializer_list&lt;std::string&gt; values) {
    for (auto&amp;&amp; value : values)
      concatenated_values += value + " SEPARATOR ";
  }
};
MyVector vec;
vec = {"hello", "everyone", "!"};</code></pre>
  </section>
</section>

<section class="slide">
  <h2><em>constexpr</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">Un mot clé pour déclarer qu'une expression est constante à la compilation.</p>
    <p class="slide">Autrement dit pour déclarer une variable / fonction que le compilateur
      peut évaluer à la compilation mais qui peut aussi être appeler à
      l'exécution.</p>
    <p class="slide"><code>constexpr int a = 12;</code></p>
    <pre class="slide"><code>constexpr int foo(int a) {
    return a + 2;
}
constexpr int b = foo(40);</code></pre>
    <p class="slide">Assez faible en C++11, de plus en plus puissant dans les nouveaux standards.</p>
  </section>

  <section class="slide">
    <h3>A quoi ça sert ?</h3>
    <ul>
      <li class="slide">Déporter une partie des traitements à la compilation.</li>
      <li class="slide">Raisonner sur les données connues à la compilation (données statiques, types, ...).</li>
    </ul>
  </section>

  <section class="slide">
    <h3>Quand l'utiliser ?</h3>
    <p>Dès que c'est possible, si votre compilateur le supporte. Il n'y a pas de désavantages à l'utiliser.</p>
  </section>
</section>

<section class="slide">
  <h2><em>Undefined behavior (UB)</em></h2>

  <section>
    <h3>Qu'est-ce que c'est ?</h3>
    <p class="slide">C'est la caractéristique d'un comportement pour lequel le langage ne <strong>définit pas de contrainte</strong>.</p>
    <p class="slide">Le compilateur peut décider de <strong>supposer que ces cas n'arrivent jamais</strong>.</p>
    <p class="slide">Par exemple car l'implémentation serait coûteuse et inutile dans la plupart des appels.</p>
    <pre class="slide"><code>int i;
std::cout &lt;&lt; i; // undefined behavior, la variable n'est pas initialisée.

i = INT_MAX;
++i; // undefined behavior, l'overflow sur les entiers signés n'est pas définie.
i / 0; // undefined behavior, division par zéro.

void foo(int a, int b);
int v = 12;
foo(++v, ++v); // undefined behavior, modification d'un objet dépendant de l'ordre d'évaluation.
    </code></pre>
  </section>
</section>

<section class="slide">
  <h2><em>Undefined behavior (UB) (2)</em></h2>
  <section>
    <h3>Pourquoi c'est important ?</h3>
    <p class="slide">L'<em>undefined behavior</em> <strong>compile toujours</strong>, sinon
      le comportement serait défini: ça ne compilerait pas.</p>
    <p class="slide">C'est ce qui le rend <strong>dangereux</strong>.</p>
    <section class="slide">
      <p>Les fonctions de la STL qui peuvent avoir un <em>UB</em> le déclarent en général.</p>
      <blockquote style="font-size: 90%">
        <p><strong>std::vector&lt;T&gt;::end</strong></p>
        <p>Returns an iterator to the element following the last element of the container.</p>
        <p>This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
      </blockquote>
    </section>
    <p class="slide">Il ne faut <strong>jamais</strong> se baser sur de l'<em>UB</em> !</p>
  </section>
</section>


<section class="slide">
  <h2><em>Undefined behavior (UB) (3)</em></h2>
  <section>
    <h3>Comment l'éviter ?</h3>
    <ul>
      <li class="slide">Lire la documentation des bibliothèques utilisées.
        <blockquote style="font-size: 90%">
          <p><strong>qint64 QDateTime::toMSecsSinceEpoch() const</strong></p>
          <p>[...]</p>
          <p>The behavior for this function is undefined if the datetime stored in this object is not valid.</p>
        </blockquote>
      </li>
      <li class="slide">Compiler avec les <em>warnings</em> activés. Dans beaucoup de cas, le compilateur vous avertira en cas d'<em>UB</em>.</li>
      <li class="slide">Documenter les préconditions et assertions des fonctions.
        <ul>
          <li><pre><code>struct MyVector {
  std::size_t size();
  /// @pre index doit être inférieur à la taille du vecteur, autrement le comportement n'est pas défini.
  int operator[](std::size_t index);
};</code></pre></li>
          <li>Tester ses préconditions avant d'appeler une fonction.</li>
        </ul>
      </li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2><em>Undefined behavior (UB) (4)</em></h2>
  <section>
    <h3><em>Unspecified behavior</em></h3>
    <p class="slide">Comportement défini mais spécifique à l'implémentation.</p>
    <pre class="slide"><code>
int foo() {
  std::cout &lt;&lt; "f";
  return 19;
}
int bar() {
  std::cout &lt;&lt; "g";
  return 42;
}
void equals(int a, int b) {
  return a == b;
}
equals(f(), g()); // unspecified behavior, "fg" ou "gf" dépend de l'implémentation du compilateur</code></pre>
    <p class="slide">Peut changer le comportement du programme lorsque le code est interpreté
    par différentes compilateurs, mais sans gravité dans la plupart des cas.</p>
  </section>
</section>

<section class="slide title">
  <h1>Questions ?</h1>
</section>

<section class="slide">
  <h2>Résumé</h2>
  <ul>
    <li class="slide">Documentation !</li>
    <li class="slide"><em>nullptr</em>, <em>range-for loop</em>, <em>auto</em>, <em>override</em>, <em>final</em>, <em>lambdas</em>.</li>
    <li class="slide"><em>RAII</em>, <em>smart pointers</em>, <em>initializer_list</em>, <em>constexpr</em>.</li>
    <li class="slide"><em>Undefined behavior</em>.</li>
  </ul>
</section>

<section class="slide">
  <h2>Prochaine session</h2>
  <ul>
    <li class="slide">Conteneurs, itérateurs et algorithmes.</li>
    <li class="slide"><em>Move semantic</em> et <em>rvalue references</em>.</li>
    <li class="slide">Code générique, <em>template metaprogramming</em>, templates variadiques.</li>
    <li class="slide"><em>ADL</em>, <em>SFINAE</em>.</li>
  </ul>
</section>

  <!--
  #########################################################################################################
  # End of content
  #########################################################################################################
  -->

      <!-- Begin extension snippets. Add or remove as needed. -->

      <!-- deck.navigation snippet -->
      <div aria-role="navigation">
        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>
      </div>

      <!-- deck.status snippet -->
      <p class="deck-status" aria-role="status">
        <span class="deck-status-current"></span>
        /
        <span class="deck-status-total"></span>
      </p>

      <!-- deck.goto snippet -->
      <form action="." method="get" class="goto-form">
        <label for="goto-slide">Go to slide:</label>
        <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
        <datalist id="goto-datalist"></datalist>
        <input type="submit" value="Go">
      </form>

      <!-- End extension snippets. -->

    </article>

  </div>

  <footer>
    <h3>Vincent PALANCHER - vincent.palancher@gmail.com</h3>
  </footer>

  <!-- Required JS files. -->
  <script src="../../contrib/deck.js/jquery.min.js"></script>
  <script src="../../contrib/deck.js/core/deck.core.js"></script>

  <!-- Extension JS files. Add or remove as needed. -->
  <script src="../../contrib/deck.js/extensions/menu/deck.menu.js"></script>
  <script src="../../contrib/deck.js/extensions/goto/deck.goto.js"></script>
  <script src="../../contrib/deck.js/extensions/status/deck.status.js"></script>
  <script src="../../contrib/deck.js/extensions/navigation/deck.navigation.js"></script>
  <script src="../../contrib/deck.js/extensions/scale/deck.scale.js"></script>

  <!-- Initialize the deck. You can put this in an external file if desired. -->
  <script>
    $(function() {
      $.deck('.slide');
    });
  </script>

  <!-- prism.js -->
  <script src="../themes/prism.js"></script>

</body>
</html>
