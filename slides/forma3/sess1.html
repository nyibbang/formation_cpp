<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>C++ moderne : perfectionnement</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../themes/ingima.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../../contrib/deck.js/themes/transition/fade.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="../../contrib/deck.js/core/print.css">

  <!-- prism.js -->
  <link rel="stylesheet" href="../themes/prism.css">

  <!-- Required Modernizr file -->
  <script src="../../contrib/deck.js/modernizr.custom.js"></script>
</head>
<body class="language-cpp">

  <header>
    <img src="../media/ingima-logo.png" class="logo">
  </header>

  <div class="home">

    <article class="deck-container">

  <!--
  #########################################################################################################
  # Content
  #
  # Title slide:
  # ------------
  # <section class="slide title">
  #   <h1>Section</h1>
  # </section>
  #
  # Slide
  # -----
  # <section class="slide">
  #   <h2>Section &rarr; Subsection</h2>
  #   <h3>Subsubsection</h3>
  #   <ul>
  #     <li><strong>Bla;</li>
  #   </ul>
  #   <p>
  #     Bla
  #   </p>
  # </section>
  #
  # Code slide
  # ---------
  # <section class="slide">
  #   <h2>Section &rarr; Subsection</h2>
  #   <h3>Subsubsection</h3>
  #   <pre><code>
  #   a = 42;
  # </code></pre>
  # </section>
  #
  # Plan
  # ----
  # <section class="slide">
  #   <h2>Section</h2>
  #   <h3>Plan</h3>
  #   <ol>
  #     <li class="faded"><h4>Passed subsection</h4></li>
  #     <li>
  #       <h4>Subsection</h4>
  #       <ol>
  #         <li>subsubsection</li>
  #       </ol>
  #     </li>
  #     <li class="faded"><h4>Incoming subsection</h4></li>
  #   </ol>
  # </section>
  #
  #########################################################################################################
  -->

<section class="slide title">
  <h1>Maîtrise et perfectionnement<br/>en C++ moderne<br/>
    <small>Première partie<br/>23 octobre 2018</small>
  </h1>
</section>

<section class="slide">
  <h2>Introduction</h2>
  <h3>Vincent Palancher, développeur C++</h3>
  <ul>
  <li class="slide">Formation d'ingénieur à l'Université de Technologie de Compiègne (UTC) en 2012.</li>
  <li class="slide">6 ans d'expérience.<ul>
      <li class="slide">6 mois chez <strong>General Electrics</strong>.
        <ul><li>Logiciel de traitement d'images médicales (C++).</li></ul>
      </li>
      <li class="slide">3 ans chez <strong>CS</strong>.
        <ul><li>Logiciel de contrôle aérien (C++11/Qt).</li></ul>
      </li>
      <li class="slide">1 an chez <strong>Ineo Défense</strong>.
        <ul><li>Logiciel de contrôle d'équipement radio (C++11/Qt5).</li></ul>
      </li>
      <li class="slide">1 an et demi chez <strong>SoftBank Robotics Europe</strong>.
        <ul><li>Bibliothèque embarquée de communication pour robot (C++11 et +).</li></ul>
      </li>
    </ul>
  </li>
  </ul>
  <h3 class="slide">A vous !</h3>
</section>

<section class="slide">
  <h2>Introduction (2)</h2>
  <h3>Objectifs</h3>
  <ul>
    <li class="slide">Arrêter le C++98/03 !</li>
    <li class="slide">Mieux comprendre le C++11.
      <ul><li>On rentrera plus en détail que la dernière formation.</li></ul>
    </li>
    <li class="slide">Se préparer aux prochaines normes.</li>
  </ul>
</section>

<section class="slide">
  <h2>Introduction (3)</h2>
  <h3>Première partie</h3>
  <ul>
    <li class="slide"><em>nullptr</em></li>
    <li class="slide"><em>for-range loop</em></li>
    <li class="slide"><em>auto</em></li>
    <li class="slide"><em>override</em>, <em>final</em></li>
    <li class="slide"><em>lambdas</em></li>
    <li class="slide"><em>smart pointers</em></li>
    <li class="slide"><em>constexpr</em></li>
    <li class="slide"><em>initializer_list</em></li>
    <li class="slide">Et plus encore.</li>
  </ul>
</section>

<section class="slide">
  <h2>Préambule</h2>
  <h3>Comment s'améliorer en C++ ?</h3>
  <p class="slide">Il suffit de lire la documentation !</p>
  <section class="slide">
    <h4>Où la trouver ?</h4>
    <ul>
      <li><a href="https://en.cppreference.com">https://en.cppreference.com</a></li>
      <li><a href="https://fr.cppreference.com">https://fr.cppreference.com</a> (pas à jour)</li>
    </ul>
  </section>
  <section class="slide">
    <h4>Outils utiles</h4>
    <ul>
      <li><a href="https://godbolt.org">https://godbolt.org</a>, pour compiler, inspecter l'asm avec différents compilateurs.</li>
      <li><a href="http://quick-bench.com">http://quick-bench.com</a>, pour benchmarker.</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Documentation</h2>
  <ul>
    <li class="slide">Compiler support.</li>
    <li class="slide">Langage.</li>
    <li class="slide">Bibliothèque standard.</li>
  </ul>
</section>

<!-- nullptr -->
<section class="slide">
  <h2><em>nullptr</em></h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Constante de type <code>std::nullptr_t</code> implicitement convertible en pointeur.</p>
    <p>Equivalent à la macro <code>NULL</code>.</p>
  </section>

  <section class="slide">
    <h3>Quel est le problème ?</h3>
    <p>
      <code>#define NULL 0</code> &rarr; type ambigu
      <pre><code>void foo(int);
void foo(void*);
foo(NULL); // Quelle overload est appelée ?</code></pre>
    </p>
  </section>

  <section class="slide">
    <h3>Solution</h3>
    <p>Remplacer tous les <code>NULL</code> par <code>nullptr</code>. Simple.</p>
    <p>A partir de C++11, <code>#define NULL nullptr</code>.</p>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo1</em></h3>
    <p>Possibilité de surcharger ses fonctions pour <code>nullptr</code>.</p>
    <p>Est-ce suffisant pour ne pas vérifier les pointeurs nuls dans les autres surcharges ?</p>
  </section>
</section>

<!-- for-range for -->
<section class="slide">
  <h2><em>range for loop</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Un moyen d'itérer simplement sur les <em>ranges</em> (comme les conteneurs).</p>
  </section>

  <section class="slide">
    <h3>Equivalence (simplifiée)</h3>
    <pre><code>for (auto&amp;&amp; elem : range) {
  code
}</code></pre>
    <pre><code>for (auto begin = range.begin(), end = range.end(); begin != end; ++begin) {
  auto&amp;&amp; elem = *begin;
  code
}</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi l'utiliser ?</h3>
    <p>Plus concis, plus clair, évite les problèmes de <em>bound checking</em>.</p>
    <pre><code>for (int i = 0; i &lt; range.size(); ++i) {
  if (range[i] == range[i + 1]) // woops, erreur simple à éviter mais obscure
    doublon();
}</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo2</em></h3>
    <p>Implémenter un range simple sur lequel itérer dans une boucle.</p>
  </section>
</section>

<!-- auto -->
<section class="slide">
  <h2>Type inference: <em>auto</em></h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Un mot clé pour forcer le compilateur à déduire le type d'une variable.</p>
    <pre><code>auto i = 42; // i est un 'int'
auto s = "abc"; // s est un 'const char*'</code></pre>
    <p>Permet de créer des variables dont le type n'est pas expressible.
      <pre><code>??? myfunc = []{ return 42; } // Woops</code></pre>
    </p>
  </section>

  <section class="slide">
    <h3>Qu'est-ce que ça n'est pas ?</h3>
    <p>Un type magique qui peut contenir n'importe quoi !</p>
    <p>Le type est <strong>déduit à la compilation</strong> et <strong>ne peut pas changer</strong>.</p>
  </section>
</section>

<section class="slide">
  <h2>Type inference: <em>auto</em> (2)</h2>
  <h3>Polémique</h3>

  <section class="slide">
    <h4>Reproches</h4>
    <ul>
      <li class="slide">On ne sait plus quel type on manipule, obfuscation du code (clarté).</li>
      <li class="slide">Pour certains développeurs, c'est un manque de rigueur (paresse).</li>
      <li class="slide">Plutôt que spécifier le type de notre variable, on
        dépend de ce que la fonction retourne (engagement).</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Type inference: <em>auto</em> (3)</h2>
  <h3>Polémique (2)</h3>
  <section class="slide">
    <h4>AAA Style (almost always auto)</h4>
    <p>Herb Sutter, membre du comité C++,
      <a href=https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/>
        lien</a>.
    </p>
    <ul>
      <li class="slide">Consistence, performance: Le compilateur ne se trompe jamais sur le
        type qu'il déduit. Il évite aussi les conversions implicites.</li>
      <li class="slide">Clarté:<br/><em>auto</em> ne cache pas nécessairement le type. Certains développeurs conseillent la syntaxe suivante.
        <pre><code>auto s = string{"abc"}; // la conversion est plus claire que 'string s{"abc"}'
                        // la syntaxe est plus homogène avec le reste du code</code></pre>
        Les IDE amortissent l'impact d'<em>auto</em> sur la lisibilité, et certains types au nom très long nuisent à
        la lecture.
        <pre><code>std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt; mymap;
std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;::iterator it = mymap.begin(); // on se répète non ?
auto it = mymap.begin(); // ça semble évident.</code></pre>
      </li>
      <li class="slide">Engagement: Il ne faut pas se rendre dépendant des implémentations mais des interfaces.<br/>
        <em>auto</em> est le <strong>concept</strong> le moins contraignant et donc le plus faible.
        <pre><code>Iterator it = myvector.begin();
// Ici Iterator ne serait pas un type mais un concept. L'interface est claire,
// l'implémentation (le véritable type) est cachée.  Le code est plus clair et documenté que
// auto it = myvector.begin();</code></pre>
      </li>
    </ul>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo3</em></h3>
    <p>Transformer les types de variables en <em>auto</em>.</p>
  </section>
</section>

<!-- override, final -->
<section class="slide">
  <h2><em>override</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Déclare que la méthode virtuelle est une réimplémentation de la méthode de la classe parente.</p>
    <pre><code>class Mother {
  virtual void do_stuff();
};
class Daughter : public Mother {
  void do_stuff() override;
};</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi c'est utile ?</h3>
    <p>Cela évite les erreurs de signatures.</p>
    <pre><code>class Mother {
  virtual void do_stuff(int a); // Quelqu'un a ajouté un paramètre !
};
class Daughter : public Mother {
  void do_stuff(); // Avant: pas d'erreur, le code compile mais la méthode n'est plus surchargée.
  void do_stuff() override; // Après: erreur de compilation
};</code></pre>
  </section>

  <section class="slide">
    <h3>Quand l'utiliser ?</h3>
    <p>Partout où c'est possible !</p>
  </section>
</section>

<section class="slide">
  <h2><em>final</em></h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Déclare qu'une méthode ou un classe ne peut pas être réimplémentée.</p>
        <pre><code>class Mother final {
};
class Daughter : public Mother { // erreur
};</code></pre>
        <pre><code>class Mother {
  virtual void do_stuff() final;
};
class Daughter : public Mother {
  void do_stuff() override; // erreur
};</code></pre>
  </section>

  <section class="slide">
    <h3>Pourquoi c'est utile ?</h3>
    <p>Empêche la surcharge et permet de mieux contrôler l'implémentation.</p>
  </section>
</section>

<section class="slide">
  <h2><em>final</em> (2)</h2>

  <section class="slide">
    <h3>Quand l'utiliser ?</h3>
    <p>Avec parcimonie.<br/>Un exemple :</p>
        <pre><code>class Base {
  virtual void do_stuff() = 0;
};
class Do_stuff_then_a_then_b_then_c : public Base {
  void do_stuff() final override { // On ne veut pas que les filles touchent à cette implem,
                                   // mais plutôt aux autres méthodes, car cela fait partie
                                   // de l'invariant de cette classe.
    do_a();
    do_b();
    do_c();
  }
  virtual void do_a() = 0;
  virtual void do_b() = 0;
  virtual void do_c() = 0;
};</code></pre>
  </section>
</section>

<section class="slide">
  <h2>Lambdas</h2>
  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p>Une fonction anonyme. Elle peut accéder aux variables de son scope.</p>
    <pre><code>void foo() {
  int a = 42;
  auto fun = [&amp;]{
    return a + 2;
  };
  int b = fun() + 10;
  assert(b == 54);
}</code></pre>
  </section>

  <section class="slide">
    <h3>Syntaxe</h3>
    <pre><code>[captures](arguments) mutable? { code }</code></pre>
    <ul>
      <li>Captures:
        <ul>
          <li>Capture par copie : <code>variable</code></li>
          <li>Capture par référence : <code>&amp;variable</code></li>
          <li>Capture tout par copie : <code>=</code></li>
          <li>Capture tout par référence : <code>&amp;</code></li>
        </ul>
      </li>
      <li><code>mutable</code> : la lambda peut modifier ses captures.</li>
    </ul>
  </section>
</section>

<section class="slide">
  <h2>Lambdas (2)</h2>
  <section class="slide">
    <h3>Equivalence</h3>
    <pre><code>struct Lambda {
  captures;
  auto operator()(arguments) const? {
    code
  }
};</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice <em>forma3_sess1_exo4</em></h3>
    <p>Chercher un élément dans un vecteur.</p>
  </section>
</section>

<section class="slide">
  <h2>RAII</h2>

  <section class="slide">
    <h3>Qu'est-ce que c'est ?</h3>
    <p><strong><em>Resource Acquisition is Initialization</em></strong>.</p>
    <p>Encapsulation d'une ressource dans un objet alloué sur la pile.<p/><p>Exemples de ressources :</p>
    <ul>
      <li>Allocation mémoire.</li>
      <li>Ouverture d'un fichier.</li>
      <li>Acquisition d'un mutex.</li>
    </ul>
    <p>En général, tout ce qui a une étape d'initialisation et une étape de nettoyage.</p>
  </section>
</section>

<section class="slide">
  <h2>RAII (2)</h2>

  <section class="slide">
    <h3>Quel intérêt ?</h3>
    <p>Protéger les ressources des multiples points de sortie d'une fonction.</p>
    <p>Une fonction peut se terminer à cause de :</p>
    <ul>
      <li>Une instruction <code>return</code>.</li>
      <li>Une exception.</li>
    </ul>
    <p>Toujours s'assurer de l'état de l'objet ou de la fonction si une exception est levée !</p>
  </section>

  <section class="slide">
    <pre><code>struct Object {
  enum State { Working, Waiting };
  State _state;

  void foo() {
    int* p = new int{42};
    _state = Working;
    bar(); // Si bar lève une exception:
           //   - fuite mémoire car le pointeur n'est pas libéré.
           //   - l'objet reste en état 'Working' alors que la fonction est terminée.
    _state = Waiting;
    delete p;
  }
};</code></pre>
  </section>
</section>

<section class="slide">
  <h2>RAII (3)</h2>

  <section class="slide">
    <h3>Comment fait-on ?</h3>
    <p>
      Si possible utiliser des types existants: <code>std::unique_ptr</code>,
      <code>std::lock_guard</code>, <code>std::unique_lock</code>, etc.
    </p>
    <pre><code>struct Raii_object {
  Resource_handle _handle;
  Raii_object()
    : _handle(alloc_resource) {
  }
  ~Raii_object() {
    release_resource(_handle);
  }
};</code></pre>
  </section>

  <section class="slide">
    <h3>Exercice forma3_sess1_exo5</h3>
    <p>Rendre une fonction <em>exception-safe</em>.</p>
  </section>
</section>

<section class="slide">
  <h2>Smart pointers</h2>
</section>

<section class="slide">
  <h2><em>initializer_list</em></h2>
</section>

<section class="slide">
  <h2><em>constexpr</em></h2>
</section>

<section class="slide">
  <h2><em>Undefined behavior</em></h2>
</section>

  <!--
  #########################################################################################################
  # End of content
  #########################################################################################################
  -->

      <!-- Begin extension snippets. Add or remove as needed. -->

      <!-- deck.navigation snippet -->
      <div aria-role="navigation">
        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>
      </div>

      <!-- deck.status snippet -->
      <p class="deck-status" aria-role="status">
        <span class="deck-status-current"></span>
        /
        <span class="deck-status-total"></span>
      </p>

      <!-- deck.goto snippet -->
      <form action="." method="get" class="goto-form">
        <label for="goto-slide">Go to slide:</label>
        <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
        <datalist id="goto-datalist"></datalist>
        <input type="submit" value="Go">
      </form>

      <!-- End extension snippets. -->

    </article>

  </div>

  <footer>
    <h3>Vincent PALANCHER - vincent.palancher@gmail.com</h3>
  </footer>

  <!-- Required JS files. -->
  <script src="../../contrib/deck.js/jquery.min.js"></script>
  <script src="../../contrib/deck.js/core/deck.core.js"></script>

  <!-- Extension JS files. Add or remove as needed. -->
  <script src="../../contrib/deck.js/extensions/menu/deck.menu.js"></script>
  <script src="../../contrib/deck.js/extensions/goto/deck.goto.js"></script>
  <script src="../../contrib/deck.js/extensions/status/deck.status.js"></script>
  <script src="../../contrib/deck.js/extensions/navigation/deck.navigation.js"></script>
  <script src="../../contrib/deck.js/extensions/scale/deck.scale.js"></script>

  <!-- Initialize the deck. You can put this in an external file if desired. -->
  <script>
    $(function() {
      $.deck('.slide');
    });
  </script>

  <!-- prism.js -->
  <script src="../themes/prism.js"></script>

</body>
</html>
